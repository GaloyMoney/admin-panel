// this file is autogenerated by codegen
/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** An Opaque Bearer token */
  AuthToken: { input: string; output: string; }
  /** Display currency of an account */
  DisplayCurrency: { input: string; output: string; }
  Language: { input: string; output: string; }
  LnPaymentPreImage: { input: string; output: string; }
  /** BOLT11 lightning invoice payment request with the amount included */
  LnPaymentRequest: { input: string; output: string; }
  LnPaymentSecret: { input: string; output: string; }
  LnPubkey: { input: string; output: string; }
  /** Text field in a lightning payment transaction */
  Memo: { input: string; output: string; }
  /** An address for an on-chain bitcoin destination */
  OnChainAddress: { input: string; output: string; }
  OnChainTxHash: { input: string; output: string; }
  /** An authentication code valid for a single use */
  OneTimeAuthCode: { input: string; output: string; }
  PaymentHash: { input: string; output: string; }
  /** Phone number which includes country code */
  Phone: { input: string; output: string; }
  /** Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1 */
  SafeInt: { input: number; output: number; }
  /** (Positive) Satoshi amount */
  SatAmount: { input: number; output: number; }
  /** An amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedAmount: { input: number; output: number; }
  /** A string amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedDisplayMajorAmount: { input: string; output: string; }
  /** (Positive) Number of blocks in which the transaction is expected to be confirmed */
  TargetConfirmations: { input: number; output: number; }
  /** Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch) */
  Timestamp: { input: number; output: number; }
  /** Unique identifier of a user */
  Username: { input: string; output: string; }
  /** Unique identifier of a wallet */
  WalletId: { input: string; output: string; }
};

/** Accounts are core to the Galoy architecture. they have users, and own wallets */
export type Account = {
  readonly __typename: 'Account';
  /** GPS coordinates for the account that can be used to place the related business on a map */
  readonly coordinates?: Maybe<Coordinates>;
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly id: Scalars['ID']['output'];
  readonly level: AccountLevel;
  readonly owner: User;
  readonly status: AccountStatus;
  readonly title?: Maybe<Scalars['String']['output']>;
  readonly username?: Maybe<Scalars['Username']['output']>;
  readonly wallets: ReadonlyArray<Wallet>;
};

export type AccountDetailPayload = {
  readonly __typename: 'AccountDetailPayload';
  readonly accountDetails?: Maybe<Account>;
  readonly errors: ReadonlyArray<Error>;
};

export const AccountLevel = {
  One: 'ONE',
  Two: 'TWO',
  Zero: 'ZERO'
} as const;

export type AccountLevel = typeof AccountLevel[keyof typeof AccountLevel];
export const AccountStatus = {
  Active: 'ACTIVE',
  Closed: 'CLOSED',
  Locked: 'LOCKED',
  New: 'NEW',
  Pending: 'PENDING'
} as const;

export type AccountStatus = typeof AccountStatus[keyof typeof AccountStatus];
export type AccountUpdateLevelInput = {
  readonly level: AccountLevel;
  readonly uid: Scalars['ID']['input'];
};

export type AccountUpdateStatusInput = {
  readonly comment?: InputMaybe<Scalars['String']['input']>;
  readonly status: AccountStatus;
  readonly uid: Scalars['ID']['input'];
};

export type AccountsAddUsdWalletInput = {
  readonly accountIds: ReadonlyArray<Scalars['ID']['input']>;
};

export type AuthTokenPayload = {
  readonly __typename: 'AuthTokenPayload';
  readonly authToken?: Maybe<Scalars['AuthToken']['output']>;
  readonly errors: ReadonlyArray<Error>;
};

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWallet = Wallet & {
  readonly __typename: 'BTCWallet';
  readonly accountId: Scalars['ID']['output'];
  /** A balance stored in BTC. */
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  /** A list of BTC transactions associated with this wallet. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type BusinessDeleteMapInfoInput = {
  readonly username: Scalars['Username']['input'];
};

export type BusinessUpdateMapInfoInput = {
  readonly latitude: Scalars['Float']['input'];
  readonly longitude: Scalars['Float']['input'];
  readonly title: Scalars['String']['input'];
  readonly username: Scalars['Username']['input'];
};

export type CaptchaCreateChallengePayload = {
  readonly __typename: 'CaptchaCreateChallengePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly result?: Maybe<CaptchaCreateChallengeResult>;
};

export type CaptchaCreateChallengeResult = {
  readonly __typename: 'CaptchaCreateChallengeResult';
  readonly challengeCode: Scalars['String']['output'];
  readonly failbackMode: Scalars['Boolean']['output'];
  readonly id: Scalars['String']['output'];
  readonly newCaptcha: Scalars['Boolean']['output'];
};

export type CaptchaRequestAuthCodeInput = {
  readonly challengeCode: Scalars['String']['input'];
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone']['input'];
  readonly secCode: Scalars['String']['input'];
  readonly validationCode: Scalars['String']['input'];
};

export type ColdStorageRebalanceToHotWalletInput = {
  readonly amount: Scalars['SatAmount']['input'];
  readonly targetConfirmations?: InputMaybe<Scalars['TargetConfirmations']['input']>;
  readonly walletName: Scalars['String']['input'];
};

export type Coordinates = {
  readonly __typename: 'Coordinates';
  readonly latitude: Scalars['Float']['output'];
  readonly longitude: Scalars['Float']['output'];
};

export type Error = {
  readonly code?: Maybe<Scalars['String']['output']>;
  readonly message: Scalars['String']['output'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
};

export type GraphQlApplicationError = Error & {
  readonly __typename: 'GraphQLApplicationError';
  readonly code?: Maybe<Scalars['String']['output']>;
  readonly message: Scalars['String']['output'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
};

export type InitiationVia = InitiationViaIntraLedger | InitiationViaLn | InitiationViaOnChain;

export type InitiationViaIntraLedger = {
  readonly __typename: 'InitiationViaIntraLedger';
  readonly counterPartyUsername?: Maybe<Scalars['Username']['output']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']['output']>;
};

export type InitiationViaLn = {
  readonly __typename: 'InitiationViaLn';
  readonly paymentHash: Scalars['PaymentHash']['output'];
};

export type InitiationViaOnChain = {
  readonly __typename: 'InitiationViaOnChain';
  readonly address: Scalars['OnChainAddress']['output'];
};

export type LightningInvoice = {
  readonly __typename: 'LightningInvoice';
  readonly confirmedAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly description: Scalars['String']['output'];
  readonly expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly isSettled: Scalars['Boolean']['output'];
  readonly received: Scalars['SatAmount']['output'];
  readonly request?: Maybe<Scalars['LnPaymentRequest']['output']>;
  readonly secretPreImage: Scalars['LnPaymentPreImage']['output'];
};

export type LightningPayment = {
  readonly __typename: 'LightningPayment';
  readonly amount?: Maybe<Scalars['SatAmount']['output']>;
  readonly confirmedAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly createdAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly destination?: Maybe<Scalars['LnPubkey']['output']>;
  readonly request?: Maybe<Scalars['LnPaymentRequest']['output']>;
  readonly revealedPreImage?: Maybe<Scalars['LnPaymentPreImage']['output']>;
  readonly roundedUpFee?: Maybe<Scalars['SatAmount']['output']>;
  readonly status?: Maybe<LnPaymentStatus>;
};

export const LnPaymentStatus = {
  Failed: 'FAILED',
  Pending: 'PENDING',
  Settled: 'SETTLED'
} as const;

export type LnPaymentStatus = typeof LnPaymentStatus[keyof typeof LnPaymentStatus];
export type Mutation = {
  readonly __typename: 'Mutation';
  readonly accountUpdateLevel: AccountDetailPayload;
  readonly accountUpdateStatus: AccountDetailPayload;
  /** @deprecated All accounts have USD wallets by default */
  readonly accountsAddUsdWallet?: Maybe<WalletDetailsPayload>;
  readonly businessDeleteMapInfo: AccountDetailPayload;
  readonly businessUpdateMapInfo: AccountDetailPayload;
  readonly captchaCreateChallenge: CaptchaCreateChallengePayload;
  readonly captchaRequestAuthCode: SuccessPayload;
  readonly coldStorageRebalanceToHotWallet: PsbtDetailPayload;
  readonly userLogin: AuthTokenPayload;
  readonly userRequestAuthCode: SuccessPayload;
  readonly userUpdatePhone: AccountDetailPayload;
};


export type MutationAccountUpdateLevelArgs = {
  input: AccountUpdateLevelInput;
};


export type MutationAccountUpdateStatusArgs = {
  input: AccountUpdateStatusInput;
};


export type MutationAccountsAddUsdWalletArgs = {
  input: AccountsAddUsdWalletInput;
};


export type MutationBusinessDeleteMapInfoArgs = {
  input: BusinessDeleteMapInfoInput;
};


export type MutationBusinessUpdateMapInfoArgs = {
  input: BusinessUpdateMapInfoInput;
};


export type MutationCaptchaRequestAuthCodeArgs = {
  input: CaptchaRequestAuthCodeInput;
};


export type MutationColdStorageRebalanceToHotWalletArgs = {
  input: ColdStorageRebalanceToHotWalletInput;
};


export type MutationUserLoginArgs = {
  input: UserLoginInput;
};


export type MutationUserRequestAuthCodeArgs = {
  input: UserRequestAuthCodeInput;
};


export type MutationUserUpdatePhoneArgs = {
  input: UserUpdatePhoneInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']['output']>;
};

export const PhoneCodeChannelType = {
  Sms: 'SMS',
  Whatsapp: 'WHATSAPP'
} as const;

export type PhoneCodeChannelType = typeof PhoneCodeChannelType[keyof typeof PhoneCodeChannelType];
export type PriceInterface = {
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

/** Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSettlementMinorUnitInDisplayMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit';
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  /** @deprecated Deprecated please use `base / 10^offset` */
  readonly formattedAmount: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

export type PsbtDetail = {
  readonly __typename: 'PsbtDetail';
  readonly fee: Scalars['SatAmount']['output'];
  readonly transaction: Scalars['String']['output'];
};

export type PsbtDetailPayload = {
  readonly __typename: 'PsbtDetailPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly psbtDetail?: Maybe<PsbtDetail>;
};

export type Query = {
  readonly __typename: 'Query';
  readonly accountDetailsByUserPhone: Account;
  readonly accountDetailsByUsername: Account;
  readonly allLevels: ReadonlyArray<AccountLevel>;
  readonly lightningInvoice: LightningInvoice;
  readonly lightningPayment: LightningPayment;
  readonly listWalletIds: ReadonlyArray<Scalars['WalletId']['output']>;
  readonly transactionById?: Maybe<Transaction>;
  readonly transactionsByHash?: Maybe<ReadonlyArray<Maybe<Transaction>>>;
  readonly wallet: Wallet;
};


export type QueryAccountDetailsByUserPhoneArgs = {
  phone: Scalars['Phone']['input'];
};


export type QueryAccountDetailsByUsernameArgs = {
  username: Scalars['Username']['input'];
};


export type QueryLightningInvoiceArgs = {
  hash: Scalars['PaymentHash']['input'];
};


export type QueryLightningPaymentArgs = {
  hash: Scalars['PaymentHash']['input'];
};


export type QueryListWalletIdsArgs = {
  walletCurrency: WalletCurrency;
};


export type QueryTransactionByIdArgs = {
  id: Scalars['ID']['input'];
};


export type QueryTransactionsByHashArgs = {
  hash: Scalars['PaymentHash']['input'];
};


export type QueryWalletArgs = {
  walletId: Scalars['WalletId']['input'];
};

export type SettlementVia = SettlementViaIntraLedger | SettlementViaLn | SettlementViaOnChain;

export type SettlementViaIntraLedger = {
  readonly __typename: 'SettlementViaIntraLedger';
  /** Settlement destination: Could be null if the payee does not have a username */
  readonly counterPartyUsername?: Maybe<Scalars['Username']['output']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']['output']>;
};

export type SettlementViaLn = {
  readonly __typename: 'SettlementViaLn';
  /** @deprecated Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type */
  readonly paymentSecret?: Maybe<Scalars['LnPaymentSecret']['output']>;
  readonly preImage?: Maybe<Scalars['LnPaymentPreImage']['output']>;
};

export type SettlementViaOnChain = {
  readonly __typename: 'SettlementViaOnChain';
  readonly transactionHash?: Maybe<Scalars['OnChainTxHash']['output']>;
  readonly vout?: Maybe<Scalars['Int']['output']>;
};

export type SuccessPayload = {
  readonly __typename: 'SuccessPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * Give details about an individual transaction.
 * Galoy have a smart routing system which is automatically
 * settling intraledger when both the payer and payee use the same wallet
 * therefore it's possible the transactions is being initiated onchain
 * or with lightning but settled intraledger.
 */
export type Transaction = {
  readonly __typename: 'Transaction';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly direction: TxDirection;
  readonly id: Scalars['ID']['output'];
  /** From which protocol the payment has been initiated. */
  readonly initiationVia: InitiationVia;
  readonly memo?: Maybe<Scalars['Memo']['output']>;
  /** Amount of the settlement currency sent or received. */
  readonly settlementAmount: Scalars['SignedAmount']['output'];
  /** Wallet currency for transaction. */
  readonly settlementCurrency: WalletCurrency;
  readonly settlementDisplayAmount: Scalars['SignedDisplayMajorAmount']['output'];
  readonly settlementDisplayCurrency: Scalars['DisplayCurrency']['output'];
  readonly settlementDisplayFee: Scalars['SignedDisplayMajorAmount']['output'];
  readonly settlementFee: Scalars['SignedAmount']['output'];
  /** Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement. */
  readonly settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit;
  /** To which protocol the payment has settled on. */
  readonly settlementVia: SettlementVia;
  readonly status: TxStatus;
};

/** A connection to a list of items. */
export type TransactionConnection = {
  readonly __typename: 'TransactionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<TransactionEdge>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TransactionEdge = {
  readonly __typename: 'TransactionEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  readonly node: Transaction;
};

export const TxDirection = {
  Receive: 'RECEIVE',
  Send: 'SEND'
} as const;

export type TxDirection = typeof TxDirection[keyof typeof TxDirection];
export const TxStatus = {
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];
/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWallet = Wallet & {
  readonly __typename: 'UsdWallet';
  readonly accountId: Scalars['ID']['output'];
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type User = {
  readonly __typename: 'User';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly id: Scalars['ID']['output'];
  readonly language: Scalars['Language']['output'];
  readonly phone: Scalars['Phone']['output'];
};

export type UserLoginInput = {
  readonly code: Scalars['OneTimeAuthCode']['input'];
  readonly phone: Scalars['Phone']['input'];
};

export type UserRequestAuthCodeInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone']['input'];
};

export type UserUpdatePhoneInput = {
  readonly phone: Scalars['Phone']['input'];
  readonly uid: Scalars['ID']['input'];
};

/** A generic wallet which stores value in one of our supported currencies. */
export type Wallet = {
  readonly accountId: Scalars['ID']['output'];
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactions?: Maybe<TransactionConnection>;
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly walletCurrency: WalletCurrency;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export const WalletCurrency = {
  Btc: 'BTC',
  Usd: 'USD'
} as const;

export type WalletCurrency = typeof WalletCurrency[keyof typeof WalletCurrency];
export type WalletDetailsPayload = {
  readonly __typename: 'WalletDetailsPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly walletDetails: ReadonlyArray<Wallet>;
};

export type AccountDetailsByUserPhoneQueryVariables = Exact<{
  phone: Scalars['Phone']['input'];
}>;


export type AccountDetailsByUserPhoneQuery = { readonly __typename: 'Query', readonly accountDetailsByUserPhone: { readonly __typename: 'Account', readonly id: string, readonly username?: string | null, readonly level: AccountLevel, readonly status: AccountStatus, readonly title?: string | null, readonly createdAt: number, readonly owner: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly phone: string, readonly createdAt: number }, readonly coordinates?: { readonly __typename: 'Coordinates', readonly latitude: number, readonly longitude: number } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number }> } };

export type BusinessDeleteMapInfoMutationVariables = Exact<{
  input: BusinessDeleteMapInfoInput;
}>;


export type BusinessDeleteMapInfoMutation = { readonly __typename: 'Mutation', readonly businessDeleteMapInfo: { readonly __typename: 'AccountDetailPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type AccountUpdateLevelMutationVariables = Exact<{
  input: AccountUpdateLevelInput;
}>;


export type AccountUpdateLevelMutation = { readonly __typename: 'Mutation', readonly accountUpdateLevel: { readonly __typename: 'AccountDetailPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly accountDetails?: { readonly __typename: 'Account', readonly id: string, readonly username?: string | null, readonly level: AccountLevel, readonly status: AccountStatus, readonly title?: string | null, readonly createdAt: number, readonly owner: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly phone: string, readonly createdAt: number }, readonly coordinates?: { readonly __typename: 'Coordinates', readonly latitude: number, readonly longitude: number } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number }> } | null } };

export type BusinessUpdateMapInfoMutationVariables = Exact<{
  input: BusinessUpdateMapInfoInput;
}>;


export type BusinessUpdateMapInfoMutation = { readonly __typename: 'Mutation', readonly businessUpdateMapInfo: { readonly __typename: 'AccountDetailPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly accountDetails?: { readonly __typename: 'Account', readonly id: string, readonly username?: string | null, readonly level: AccountLevel, readonly status: AccountStatus, readonly title?: string | null, readonly createdAt: number, readonly owner: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly phone: string, readonly createdAt: number }, readonly coordinates?: { readonly __typename: 'Coordinates', readonly latitude: number, readonly longitude: number } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number }> } | null } };

export type AccountUpdateStatusMutationVariables = Exact<{
  input: AccountUpdateStatusInput;
}>;


export type AccountUpdateStatusMutation = { readonly __typename: 'Mutation', readonly accountUpdateStatus: { readonly __typename: 'AccountDetailPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly accountDetails?: { readonly __typename: 'Account', readonly id: string, readonly username?: string | null, readonly level: AccountLevel, readonly status: AccountStatus, readonly title?: string | null, readonly createdAt: number, readonly owner: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly phone: string, readonly createdAt: number }, readonly coordinates?: { readonly __typename: 'Coordinates', readonly latitude: number, readonly longitude: number } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number }> } | null } };

export type AccountDetailsByUsernameQueryVariables = Exact<{
  username: Scalars['Username']['input'];
}>;


export type AccountDetailsByUsernameQuery = { readonly __typename: 'Query', readonly accountDetailsByUsername: { readonly __typename: 'Account', readonly id: string, readonly username?: string | null, readonly level: AccountLevel, readonly status: AccountStatus, readonly title?: string | null, readonly createdAt: number, readonly owner: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly phone: string, readonly createdAt: number }, readonly coordinates?: { readonly __typename: 'Coordinates', readonly latitude: number, readonly longitude: number } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly accountId: string, readonly balance: number, readonly pendingIncomingBalance: number }> } };

export type CaptchaCreateChallengeMutationVariables = Exact<{ [key: string]: never; }>;


export type CaptchaCreateChallengeMutation = { readonly __typename: 'Mutation', readonly captchaCreateChallenge: { readonly __typename: 'CaptchaCreateChallengePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly result?: { readonly __typename: 'CaptchaCreateChallengeResult', readonly id: string, readonly challengeCode: string, readonly newCaptcha: boolean, readonly failbackMode: boolean } | null } };

export type CaptchaRequestAuthCodeMutationVariables = Exact<{
  input: CaptchaRequestAuthCodeInput;
}>;


export type CaptchaRequestAuthCodeMutation = { readonly __typename: 'Mutation', readonly captchaRequestAuthCode: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LightningInvoiceQueryVariables = Exact<{
  hash: Scalars['PaymentHash']['input'];
}>;


export type LightningInvoiceQuery = { readonly __typename: 'Query', readonly lightningInvoice: { readonly __typename: 'LightningInvoice', readonly createdAt: number, readonly confirmedAt?: number | null, readonly description: string, readonly expiresAt?: number | null, readonly isSettled: boolean, readonly received: number, readonly request?: string | null, readonly secretPreImage: string } };

export type LightningPaymentQueryVariables = Exact<{
  hash: Scalars['PaymentHash']['input'];
}>;


export type LightningPaymentQuery = { readonly __typename: 'Query', readonly lightningPayment: { readonly __typename: 'LightningPayment', readonly createdAt?: number | null, readonly confirmedAt?: number | null, readonly status?: LnPaymentStatus | null, readonly amount?: number | null, readonly roundedUpFee?: number | null, readonly revealedPreImage?: string | null, readonly request?: string | null, readonly destination?: string | null } };

export type TransactionsByHashQueryVariables = Exact<{
  hash: Scalars['PaymentHash']['input'];
}>;


export type TransactionsByHashQuery = { readonly __typename: 'Query', readonly transactionsByHash?: ReadonlyArray<{ readonly __typename: 'Transaction', readonly id: string, readonly settlementAmount: number, readonly settlementFee: number, readonly direction: TxDirection, readonly status: TxStatus, readonly memo?: string | null, readonly createdAt: number, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'SettlementViaLn', readonly paymentSecret?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null }, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string } } | null> | null };

export type TransactionByIdQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type TransactionByIdQuery = { readonly __typename: 'Query', readonly transactionById?: { readonly __typename: 'Transaction', readonly id: string, readonly settlementAmount: number, readonly settlementFee: number, readonly direction: TxDirection, readonly status: TxStatus, readonly memo?: string | null, readonly createdAt: number, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'SettlementViaLn', readonly paymentSecret?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null }, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string } } | null };


export const AccountDetailsByUserPhoneDocument = gql`
    query accountDetailsByUserPhone($phone: Phone!) {
  accountDetailsByUserPhone(phone: $phone) {
    id
    username
    level
    status
    title
    owner {
      id
      language
      phone
      createdAt
    }
    coordinates {
      latitude
      longitude
    }
    wallets {
      id
      walletCurrency
      accountId
      balance
      pendingIncomingBalance
    }
    createdAt
  }
}
    `;

/**
 * __useAccountDetailsByUserPhoneQuery__
 *
 * To run a query within a React component, call `useAccountDetailsByUserPhoneQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDetailsByUserPhoneQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDetailsByUserPhoneQuery({
 *   variables: {
 *      phone: // value for 'phone'
 *   },
 * });
 */
export function useAccountDetailsByUserPhoneQuery(baseOptions: Apollo.QueryHookOptions<AccountDetailsByUserPhoneQuery, AccountDetailsByUserPhoneQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountDetailsByUserPhoneQuery, AccountDetailsByUserPhoneQueryVariables>(AccountDetailsByUserPhoneDocument, options);
      }
export function useAccountDetailsByUserPhoneLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountDetailsByUserPhoneQuery, AccountDetailsByUserPhoneQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountDetailsByUserPhoneQuery, AccountDetailsByUserPhoneQueryVariables>(AccountDetailsByUserPhoneDocument, options);
        }
export type AccountDetailsByUserPhoneQueryHookResult = ReturnType<typeof useAccountDetailsByUserPhoneQuery>;
export type AccountDetailsByUserPhoneLazyQueryHookResult = ReturnType<typeof useAccountDetailsByUserPhoneLazyQuery>;
export type AccountDetailsByUserPhoneQueryResult = Apollo.QueryResult<AccountDetailsByUserPhoneQuery, AccountDetailsByUserPhoneQueryVariables>;
export const BusinessDeleteMapInfoDocument = gql`
    mutation businessDeleteMapInfo($input: BusinessDeleteMapInfoInput!) {
  businessDeleteMapInfo(input: $input) {
    errors {
      message
    }
  }
}
    `;
export type BusinessDeleteMapInfoMutationFn = Apollo.MutationFunction<BusinessDeleteMapInfoMutation, BusinessDeleteMapInfoMutationVariables>;

/**
 * __useBusinessDeleteMapInfoMutation__
 *
 * To run a mutation, you first call `useBusinessDeleteMapInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBusinessDeleteMapInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [businessDeleteMapInfoMutation, { data, loading, error }] = useBusinessDeleteMapInfoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBusinessDeleteMapInfoMutation(baseOptions?: Apollo.MutationHookOptions<BusinessDeleteMapInfoMutation, BusinessDeleteMapInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BusinessDeleteMapInfoMutation, BusinessDeleteMapInfoMutationVariables>(BusinessDeleteMapInfoDocument, options);
      }
export type BusinessDeleteMapInfoMutationHookResult = ReturnType<typeof useBusinessDeleteMapInfoMutation>;
export type BusinessDeleteMapInfoMutationResult = Apollo.MutationResult<BusinessDeleteMapInfoMutation>;
export type BusinessDeleteMapInfoMutationOptions = Apollo.BaseMutationOptions<BusinessDeleteMapInfoMutation, BusinessDeleteMapInfoMutationVariables>;
export const AccountUpdateLevelDocument = gql`
    mutation accountUpdateLevel($input: AccountUpdateLevelInput!) {
  accountUpdateLevel(input: $input) {
    errors {
      message
    }
    accountDetails {
      id
      username
      level
      status
      title
      owner {
        id
        language
        phone
        createdAt
      }
      coordinates {
        latitude
        longitude
      }
      wallets {
        id
        walletCurrency
        accountId
        balance
        pendingIncomingBalance
      }
      createdAt
    }
  }
}
    `;
export type AccountUpdateLevelMutationFn = Apollo.MutationFunction<AccountUpdateLevelMutation, AccountUpdateLevelMutationVariables>;

/**
 * __useAccountUpdateLevelMutation__
 *
 * To run a mutation, you first call `useAccountUpdateLevelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateLevelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateLevelMutation, { data, loading, error }] = useAccountUpdateLevelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateLevelMutation(baseOptions?: Apollo.MutationHookOptions<AccountUpdateLevelMutation, AccountUpdateLevelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountUpdateLevelMutation, AccountUpdateLevelMutationVariables>(AccountUpdateLevelDocument, options);
      }
export type AccountUpdateLevelMutationHookResult = ReturnType<typeof useAccountUpdateLevelMutation>;
export type AccountUpdateLevelMutationResult = Apollo.MutationResult<AccountUpdateLevelMutation>;
export type AccountUpdateLevelMutationOptions = Apollo.BaseMutationOptions<AccountUpdateLevelMutation, AccountUpdateLevelMutationVariables>;
export const BusinessUpdateMapInfoDocument = gql`
    mutation businessUpdateMapInfo($input: BusinessUpdateMapInfoInput!) {
  businessUpdateMapInfo(input: $input) {
    errors {
      message
    }
    accountDetails {
      id
      username
      level
      status
      title
      owner {
        id
        language
        phone
        createdAt
      }
      coordinates {
        latitude
        longitude
      }
      wallets {
        id
        walletCurrency
        accountId
        balance
        pendingIncomingBalance
      }
      createdAt
    }
  }
}
    `;
export type BusinessUpdateMapInfoMutationFn = Apollo.MutationFunction<BusinessUpdateMapInfoMutation, BusinessUpdateMapInfoMutationVariables>;

/**
 * __useBusinessUpdateMapInfoMutation__
 *
 * To run a mutation, you first call `useBusinessUpdateMapInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBusinessUpdateMapInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [businessUpdateMapInfoMutation, { data, loading, error }] = useBusinessUpdateMapInfoMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useBusinessUpdateMapInfoMutation(baseOptions?: Apollo.MutationHookOptions<BusinessUpdateMapInfoMutation, BusinessUpdateMapInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BusinessUpdateMapInfoMutation, BusinessUpdateMapInfoMutationVariables>(BusinessUpdateMapInfoDocument, options);
      }
export type BusinessUpdateMapInfoMutationHookResult = ReturnType<typeof useBusinessUpdateMapInfoMutation>;
export type BusinessUpdateMapInfoMutationResult = Apollo.MutationResult<BusinessUpdateMapInfoMutation>;
export type BusinessUpdateMapInfoMutationOptions = Apollo.BaseMutationOptions<BusinessUpdateMapInfoMutation, BusinessUpdateMapInfoMutationVariables>;
export const AccountUpdateStatusDocument = gql`
    mutation accountUpdateStatus($input: AccountUpdateStatusInput!) {
  accountUpdateStatus(input: $input) {
    errors {
      message
    }
    accountDetails {
      id
      username
      level
      status
      title
      owner {
        id
        language
        phone
        createdAt
      }
      coordinates {
        latitude
        longitude
      }
      wallets {
        id
        walletCurrency
        accountId
        balance
        pendingIncomingBalance
      }
      createdAt
    }
  }
}
    `;
export type AccountUpdateStatusMutationFn = Apollo.MutationFunction<AccountUpdateStatusMutation, AccountUpdateStatusMutationVariables>;

/**
 * __useAccountUpdateStatusMutation__
 *
 * To run a mutation, you first call `useAccountUpdateStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateStatusMutation, { data, loading, error }] = useAccountUpdateStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateStatusMutation(baseOptions?: Apollo.MutationHookOptions<AccountUpdateStatusMutation, AccountUpdateStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountUpdateStatusMutation, AccountUpdateStatusMutationVariables>(AccountUpdateStatusDocument, options);
      }
export type AccountUpdateStatusMutationHookResult = ReturnType<typeof useAccountUpdateStatusMutation>;
export type AccountUpdateStatusMutationResult = Apollo.MutationResult<AccountUpdateStatusMutation>;
export type AccountUpdateStatusMutationOptions = Apollo.BaseMutationOptions<AccountUpdateStatusMutation, AccountUpdateStatusMutationVariables>;
export const AccountDetailsByUsernameDocument = gql`
    query accountDetailsByUsername($username: Username!) {
  accountDetailsByUsername(username: $username) {
    id
    username
    level
    status
    title
    owner {
      id
      language
      phone
      createdAt
    }
    coordinates {
      latitude
      longitude
    }
    wallets {
      id
      walletCurrency
      accountId
      balance
      pendingIncomingBalance
    }
    createdAt
  }
}
    `;

/**
 * __useAccountDetailsByUsernameQuery__
 *
 * To run a query within a React component, call `useAccountDetailsByUsernameQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDetailsByUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDetailsByUsernameQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDetailsByUsernameQuery(baseOptions: Apollo.QueryHookOptions<AccountDetailsByUsernameQuery, AccountDetailsByUsernameQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountDetailsByUsernameQuery, AccountDetailsByUsernameQueryVariables>(AccountDetailsByUsernameDocument, options);
      }
export function useAccountDetailsByUsernameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountDetailsByUsernameQuery, AccountDetailsByUsernameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountDetailsByUsernameQuery, AccountDetailsByUsernameQueryVariables>(AccountDetailsByUsernameDocument, options);
        }
export type AccountDetailsByUsernameQueryHookResult = ReturnType<typeof useAccountDetailsByUsernameQuery>;
export type AccountDetailsByUsernameLazyQueryHookResult = ReturnType<typeof useAccountDetailsByUsernameLazyQuery>;
export type AccountDetailsByUsernameQueryResult = Apollo.QueryResult<AccountDetailsByUsernameQuery, AccountDetailsByUsernameQueryVariables>;
export const CaptchaCreateChallengeDocument = gql`
    mutation captchaCreateChallenge {
  captchaCreateChallenge {
    errors {
      message
    }
    result {
      id
      challengeCode
      newCaptcha
      failbackMode
    }
  }
}
    `;
export type CaptchaCreateChallengeMutationFn = Apollo.MutationFunction<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>;

/**
 * __useCaptchaCreateChallengeMutation__
 *
 * To run a mutation, you first call `useCaptchaCreateChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaCreateChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaCreateChallengeMutation, { data, loading, error }] = useCaptchaCreateChallengeMutation({
 *   variables: {
 *   },
 * });
 */
export function useCaptchaCreateChallengeMutation(baseOptions?: Apollo.MutationHookOptions<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>(CaptchaCreateChallengeDocument, options);
      }
export type CaptchaCreateChallengeMutationHookResult = ReturnType<typeof useCaptchaCreateChallengeMutation>;
export type CaptchaCreateChallengeMutationResult = Apollo.MutationResult<CaptchaCreateChallengeMutation>;
export type CaptchaCreateChallengeMutationOptions = Apollo.BaseMutationOptions<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>;
export const CaptchaRequestAuthCodeDocument = gql`
    mutation captchaRequestAuthCode($input: CaptchaRequestAuthCodeInput!) {
  captchaRequestAuthCode(input: $input) {
    errors {
      message
    }
    success
  }
}
    `;
export type CaptchaRequestAuthCodeMutationFn = Apollo.MutationFunction<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>;

/**
 * __useCaptchaRequestAuthCodeMutation__
 *
 * To run a mutation, you first call `useCaptchaRequestAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaRequestAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaRequestAuthCodeMutation, { data, loading, error }] = useCaptchaRequestAuthCodeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCaptchaRequestAuthCodeMutation(baseOptions?: Apollo.MutationHookOptions<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>(CaptchaRequestAuthCodeDocument, options);
      }
export type CaptchaRequestAuthCodeMutationHookResult = ReturnType<typeof useCaptchaRequestAuthCodeMutation>;
export type CaptchaRequestAuthCodeMutationResult = Apollo.MutationResult<CaptchaRequestAuthCodeMutation>;
export type CaptchaRequestAuthCodeMutationOptions = Apollo.BaseMutationOptions<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>;
export const LightningInvoiceDocument = gql`
    query lightningInvoice($hash: PaymentHash!) {
  lightningInvoice(hash: $hash) {
    createdAt
    confirmedAt
    description
    expiresAt
    isSettled
    received
    request
    secretPreImage
  }
}
    `;

/**
 * __useLightningInvoiceQuery__
 *
 * To run a query within a React component, call `useLightningInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useLightningInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLightningInvoiceQuery({
 *   variables: {
 *      hash: // value for 'hash'
 *   },
 * });
 */
export function useLightningInvoiceQuery(baseOptions: Apollo.QueryHookOptions<LightningInvoiceQuery, LightningInvoiceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LightningInvoiceQuery, LightningInvoiceQueryVariables>(LightningInvoiceDocument, options);
      }
export function useLightningInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LightningInvoiceQuery, LightningInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LightningInvoiceQuery, LightningInvoiceQueryVariables>(LightningInvoiceDocument, options);
        }
export type LightningInvoiceQueryHookResult = ReturnType<typeof useLightningInvoiceQuery>;
export type LightningInvoiceLazyQueryHookResult = ReturnType<typeof useLightningInvoiceLazyQuery>;
export type LightningInvoiceQueryResult = Apollo.QueryResult<LightningInvoiceQuery, LightningInvoiceQueryVariables>;
export const LightningPaymentDocument = gql`
    query lightningPayment($hash: PaymentHash!) {
  lightningPayment(hash: $hash) {
    createdAt
    confirmedAt
    status
    amount
    roundedUpFee
    revealedPreImage
    request
    destination
  }
}
    `;

/**
 * __useLightningPaymentQuery__
 *
 * To run a query within a React component, call `useLightningPaymentQuery` and pass it any options that fit your needs.
 * When your component renders, `useLightningPaymentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLightningPaymentQuery({
 *   variables: {
 *      hash: // value for 'hash'
 *   },
 * });
 */
export function useLightningPaymentQuery(baseOptions: Apollo.QueryHookOptions<LightningPaymentQuery, LightningPaymentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LightningPaymentQuery, LightningPaymentQueryVariables>(LightningPaymentDocument, options);
      }
export function useLightningPaymentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LightningPaymentQuery, LightningPaymentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LightningPaymentQuery, LightningPaymentQueryVariables>(LightningPaymentDocument, options);
        }
export type LightningPaymentQueryHookResult = ReturnType<typeof useLightningPaymentQuery>;
export type LightningPaymentLazyQueryHookResult = ReturnType<typeof useLightningPaymentLazyQuery>;
export type LightningPaymentQueryResult = Apollo.QueryResult<LightningPaymentQuery, LightningPaymentQueryVariables>;
export const TransactionsByHashDocument = gql`
    query transactionsByHash($hash: PaymentHash!) {
  transactionsByHash(hash: $hash) {
    id
    initiationVia {
      __typename
      ... on InitiationViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on InitiationViaLn {
        paymentHash
      }
      ... on InitiationViaOnChain {
        address
      }
    }
    settlementVia {
      __typename
      ... on SettlementViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on SettlementViaLn {
        paymentSecret
      }
      ... on SettlementViaOnChain {
        transactionHash
      }
    }
    settlementAmount
    settlementFee
    settlementPrice {
      base
      offset
      currencyUnit
      formattedAmount
    }
    direction
    status
    memo
    createdAt
  }
}
    `;

/**
 * __useTransactionsByHashQuery__
 *
 * To run a query within a React component, call `useTransactionsByHashQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionsByHashQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionsByHashQuery({
 *   variables: {
 *      hash: // value for 'hash'
 *   },
 * });
 */
export function useTransactionsByHashQuery(baseOptions: Apollo.QueryHookOptions<TransactionsByHashQuery, TransactionsByHashQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TransactionsByHashQuery, TransactionsByHashQueryVariables>(TransactionsByHashDocument, options);
      }
export function useTransactionsByHashLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TransactionsByHashQuery, TransactionsByHashQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TransactionsByHashQuery, TransactionsByHashQueryVariables>(TransactionsByHashDocument, options);
        }
export type TransactionsByHashQueryHookResult = ReturnType<typeof useTransactionsByHashQuery>;
export type TransactionsByHashLazyQueryHookResult = ReturnType<typeof useTransactionsByHashLazyQuery>;
export type TransactionsByHashQueryResult = Apollo.QueryResult<TransactionsByHashQuery, TransactionsByHashQueryVariables>;
export const TransactionByIdDocument = gql`
    query transactionById($id: ID!) {
  transactionById(id: $id) {
    id
    initiationVia {
      __typename
      ... on InitiationViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on InitiationViaLn {
        paymentHash
      }
      ... on InitiationViaOnChain {
        address
      }
    }
    settlementVia {
      __typename
      ... on SettlementViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on SettlementViaLn {
        paymentSecret
      }
      ... on SettlementViaOnChain {
        transactionHash
      }
    }
    settlementAmount
    settlementFee
    settlementPrice {
      base
      offset
      currencyUnit
      formattedAmount
    }
    direction
    status
    memo
    createdAt
  }
}
    `;

/**
 * __useTransactionByIdQuery__
 *
 * To run a query within a React component, call `useTransactionByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useTransactionByIdQuery(baseOptions: Apollo.QueryHookOptions<TransactionByIdQuery, TransactionByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TransactionByIdQuery, TransactionByIdQueryVariables>(TransactionByIdDocument, options);
      }
export function useTransactionByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TransactionByIdQuery, TransactionByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TransactionByIdQuery, TransactionByIdQueryVariables>(TransactionByIdDocument, options);
        }
export type TransactionByIdQueryHookResult = ReturnType<typeof useTransactionByIdQuery>;
export type TransactionByIdLazyQueryHookResult = ReturnType<typeof useTransactionByIdLazyQuery>;
export type TransactionByIdQueryResult = Apollo.QueryResult<TransactionByIdQuery, TransactionByIdQueryVariables>;